<html>
  <head>
    <!-- Load the latest version of TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.3.0/dist/tf.min.js"></script>
    
  </head>
  <body>
    <div id="console"></div>
    <!-- Add an image that we will use to test -->
    <!-- Load index.js after the content of the page -->
    <script src="tiny-yolov2.js"></script>
    <script src="FileSaver.js"></script>
    <script src="createLossReporter.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    
    <div style="position: relative" class="margin">
      <img id="inputImg" src="http://127.0.0.1:8000/train/duck2.jpg" crossorigin='anonymous' style="max-width: 800px;" />
      <canvas id="overlay" />
    </div>
    
    
    <script>

        async function app(){
            const config = {
              // use separable convolutions over regular convolutions
              "withSeparableConvs": true,
              // iou threshold for nonMaxSuppression
              "iouThreshold": 0.4,
              // instructions for how to determine anchors is given below
              "anchors": [
                { "x": 1.08, "y": 1.19 },
                { "x": 3.42, "y": 4.41 },
                { "x": 6.63, "y": 11.38 },
                { "x": 9.42, "y": 5.11 },
                { "x": 16.62, "y": 10.52 }
              ],
              // whatever kind of objects you are training your object detector on
              "classes": ["duck"],
              // optionally you can compute the mean RGB value for your dataset and
              // pass it in the config for performing mean value subtraction on your
              // input images
              // scale factors for each loss term (only required for training),
              // explained below
              "objectScale": 5,
              "noObjectScale": 1,
              "coordScale": 1,
              "classScale": 1
            }

            // simply use any of the optimizer provided by tfjs (I usually use adam)ss
            const learningRate = 0.001
            const optimizer = yolo.tf.train.adam(learningRate, 0.9, 0.999, 1e-8)
            
            // initialize a trainable TinyYolov2
            const net = new yolo.TinyYolov2Trainable(config, optimizer)
            
            // load initial weights or the weights of any checkpoint
            const checkpointUri = 'http://127.0.0.1:8000/temp/initial_glorot_1_classes.weights'
            const weights = new Float32Array(await (await fetch(checkpointUri)).arrayBuffer())
            console.log("started")
            await net.load(weights)

            
            //const boxJsonUris = (await fetch('http://127.0.0.1:3000/BoxJsonUris')).json()
            const boxJsonUris = ['http://127.0.0.1:8000/train/duck1.json','http://127.0.0.1:8000/train/duck2.json']
            console.log(JSON.stringify(boxJsonUris))
            
            const trainingSizes = [160, 224, 320, 416]
            const lossReporter = createLossReporter(trainingSizes)
            const startEpoch = 0
            const maxEpoch = 10
            var saveEveryNthSample = 500
            
            
            function saveWeights(net, filename = 'train_tmp') {
              saveAs(new Blob([net.serializeParams()]), filename)
            }

            for (let epoch = startEpoch; epoch < maxEpoch; epoch++) {
              console.log('epoch : ', epoch)
              // always shuffle your inputs for each epoch
              const shuffledInputs = yolo.shuffleArray(boxJsonUris)
              console.log('Debug1',shuffledInputs)

              //console.log('Debug2')
              lossReporter.resetLosses()
              //console.log('Debug3')

              // loop through shuffled inputs
              for (let dataIdx = 0; dataIdx < shuffledInputs.length; dataIdx++) {

                // fetch image and corresponding ground truth bounding boxes
                //console.log('Debug4')
                const boxJsonUri = shuffledInputs[dataIdx]
                console.log('Debug5 : ',boxJsonUri)
                const imgUri = boxJsonUri.replace('.json', '.jpg')
                //console.log('Debug6 : ',imgUri)
                const groundTruth = await (await fetch(boxJsonUri)).json()
                //console.log('Debug7 : ',groundTruth)
                const img = await yolo.bufferToImage(await (await fetch(imgUri)).blob())
                
               
                // rescale and backward pass input image for each input size
                for (let sizeIdx = 0; sizeIdx < trainingSizes.length; sizeIdx++) {

                  const inputSize = trainingSizes[sizeIdx]
                  
                  const backwardOptions = {
                    // filter boxes with width < 32 or height < 32
                    minBoxSize: 32,
                    // log computed losses
                    reportLosses: function({ losses, numBoxes, inputSize }) {
                      console.log(`ground truth boxes: ${numBoxes} (${inputSize})`)
                      console.log(`noObjectLoss[${dataIdx}]: ${yolo.round(losses.noObjectLoss, 4)}`)
                      console.log(`objectLoss[${dataIdx}]: ${yolo.round(losses.objectLoss, 4)}`)
                      console.log(`coordLoss[${dataIdx}]: ${yolo.round(losses.coordLoss, 4)}`)
                      console.log(`classLoss[${dataIdx}]: ${yolo.round(losses.classLoss, 4)}`)
                      console.log(`totalLoss[${dataIdx}]: ${yolo.round(losses.totalLoss, 4)}`)
                      lossReporter.reportLosses({ losses, numBoxes, inputSize })
                    }
                  }
                  

                  const loss = await net.backward(img, groundTruth, inputSize, backwardOptions)
                  if (epoch !== startEpoch && epoch == 9) {
                    saveWeights(net, `custom_epoch${epoch - 1}.weights`)
                    saveAs(new Blob([JSON.stringify(lossReporter.summary())]), `custom_losses_epoch${epoch - 1}.json`)
                  }
                  //console.log("started2")
                  //onBackwardComplete(epoch, dataIdx, inputSize)
                  if (loss) {
                    // don't forget to free the loss tensor
                    loss.dispose()
                  } else {
                    console.log('no boxes remaining after filtering')
                  }

                }
              }
            }
            console.log("train Ended")
            

        }
    
        app();
        
    </script>
    
    
    
    
  </body>
</html>
